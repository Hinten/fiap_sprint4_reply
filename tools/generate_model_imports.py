#!/usr/bin/env python3
"""
Static code generator for Model imports.

This script scans the models directory for Python files that contain classes
inheriting from Model, and generates a Python file with a function that imports
all those modules statically.

This replaces the fragile dynamic import mechanism with deterministic static imports
to improve Streamlit dashboard reliability.
"""

import ast
import os
import sys
from pathlib import Path
from typing import List, Set

# Add parent directory to path so we can import from src
SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Configuration
MODELS_DIR = PROJECT_ROOT / "src" / "database" / "models"
OUTPUT_FILE = PROJECT_ROOT / "src" / "database" / "generated_models_imports.py"


def file_contains_model_subclass(file_path: Path) -> bool:
    """
    Parse a Python file with AST to detect if it contains classes inheriting from Model.
    
    Args:
        file_path: Path to the Python file to analyze
        
    Returns:
        True if the file contains at least one class that inherits from Model
    """
    try:
        content = file_path.read_text(encoding='utf-8')
        tree = ast.parse(content, filename=str(file_path))
    except (SyntaxError, UnicodeDecodeError) as e:
        print(f"Warning: Could not parse {file_path}: {e}")
        return False
    
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for base in node.bases:
                # Check for simple Name nodes (e.g., class Foo(Model))
                if isinstance(base, ast.Name) and base.id == "Model":
                    return True
                # Check for Attribute nodes (e.g., class Foo(module.Model))
                if isinstance(base, ast.Attribute) and base.attr == "Model":
                    return True
    
    return False


def find_modules_with_models(models_dir: Path, project_root: Path = None) -> List[str]:
    """
    Scan the models directory for Python files containing Model subclasses.
    
    Args:
        models_dir: Directory to scan for model files
        project_root: Root directory for calculating relative module paths (defaults to PROJECT_ROOT)
        
    Returns:
        Sorted list of module import paths (e.g., ['src.database.models.empresa'])
    """
    if project_root is None:
        project_root = PROJECT_ROOT
    
    modules: Set[str] = set()
    
    if not models_dir.exists():
        print(f"Warning: Models directory does not exist: {models_dir}")
        return []
    
    # Recursively find all .py files
    for py_file in models_dir.rglob("*.py"):
        # Skip __init__.py and other special files
        if py_file.name.startswith("__"):
            continue
        
        # Skip files that don't contain Model subclasses
        if not file_contains_model_subclass(py_file):
            continue
        
        # Build module import path relative to project root
        # e.g., src/database/models/empresa.py -> src.database.models.empresa
        try:
            rel_path = py_file.relative_to(project_root)
            module_path = ".".join(rel_path.with_suffix("").parts)
            modules.add(module_path)
        except ValueError:
            print(f"Warning: Could not determine relative path for {py_file}")
            continue
    
    return sorted(modules)


def generate_imports_file(modules: List[str], output_path: Path) -> None:
    """
    Generate the Python file containing the import_generated_models function.
    
    Args:
        modules: List of module paths to import
        output_path: Where to write the generated file
    """
    lines = [
        "# AUTOGENERATED FILE - DO NOT EDIT",
        "# Generated by tools/generate_model_imports.py",
        "#",
        "# This file contains static imports for all Model subclasses.",
        "# It is generated at Docker build time to replace dynamic imports.",
        "",
        "import importlib",
        "import logging",
        "",
        "logger = logging.getLogger(__name__)",
        "",
        "",
        "def import_generated_models() -> None:",
        '    """',
        "    Import all modules that contain Model subclasses.",
        "    ",
        "    This function is called by import_models() to statically import",
        "    all model modules, providing better performance and determinism",
        "    than dynamic imports at runtime.",
        '    """',
    ]
    
    if not modules:
        lines.append("    # No model modules found")
        lines.append("    pass")
    else:
        lines.append(f"    # Importing {len(modules)} model module(s)")
        for module in modules:
            lines.append(f"    try:")
            lines.append(f'        importlib.import_module("{module}")')
            lines.append(f"    except ImportError as e:")
            lines.append(f'        logger.error(f"Failed to import {module}: {{e}}")')
    
    lines.append("")
    
    content = "\n".join(lines)
    output_path.write_text(content, encoding='utf-8')
    print(f"✓ Generated {output_path}")
    print(f"  - Found {len(modules)} module(s) with Model subclasses")
    if modules:
        for module in modules:
            print(f"    • {module}")


def main():
    """Main entry point for the generator script."""
    print("Static Model Imports Generator")
    print("=" * 50)
    print(f"Project root: {PROJECT_ROOT}")
    print(f"Models directory: {MODELS_DIR}")
    print(f"Output file: {OUTPUT_FILE}")
    print()
    
    # Find all modules with Model subclasses
    modules = find_modules_with_models(MODELS_DIR)
    
    # Generate the imports file
    generate_imports_file(modules, OUTPUT_FILE)
    
    print()
    print("✓ Generation complete!")


if __name__ == "__main__":
    main()
