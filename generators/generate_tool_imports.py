#!/usr/bin/env python3
"""
Static code generator for Tool imports.

This script scans the tools directory for Python files that contain classes
inheriting from BaseTool, and generates a Python file with a function that imports
all those modules statically.

This replaces the fragile dynamic import mechanism with deterministic static imports
to improve reliability and performance.
"""

import ast
import os
import sys
from pathlib import Path
from typing import List, Set

# Add parent directory to path so we can import from src
SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Configuration
TOOLS_DIR = PROJECT_ROOT / "src" / "large_language_model" / "tools"
OUTPUT_FILE = PROJECT_ROOT / "src" / "large_language_model" / "generated_tools_imports.py"


def file_contains_basetool_subclass(file_path: Path) -> bool:
    """
    Parse a Python file with AST to detect if it contains classes inheriting from BaseTool.
    
    Args:
        file_path: Path to the Python file to analyze
        
    Returns:
        True if the file contains at least one class that inherits from BaseTool
    """
    try:
        content = file_path.read_text(encoding='utf-8')
        tree = ast.parse(content, filename=str(file_path))
    except (SyntaxError, UnicodeDecodeError) as e:
        print(f"Warning: Could not parse {file_path}: {e}")
        return False
    
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for base in node.bases:
                # Check for simple Name nodes (e.g., class Foo(BaseTool))
                if isinstance(base, ast.Name) and base.id == "BaseTool":
                    return True
                # Check for Attribute nodes (e.g., class Foo(module.BaseTool))
                if isinstance(base, ast.Attribute) and base.attr == "BaseTool":
                    return True
    
    return False


def find_modules_with_tools(tools_dir: Path, project_root: Path = None) -> List[str]:
    """
    Scan the tools directory for Python files containing BaseTool subclasses.
    
    Args:
        tools_dir: Directory to scan for tool files
        project_root: Root directory for calculating relative module paths (defaults to PROJECT_ROOT)
        
    Returns:
        Sorted list of module import paths (e.g., ['src.large_language_model.tools.datetime_tool'])
    """
    if project_root is None:
        project_root = PROJECT_ROOT
    
    modules: Set[str] = set()
    
    if not tools_dir.exists():
        print(f"Warning: Tools directory does not exist: {tools_dir}")
        return []
    
    # Recursively find all .py files
    for py_file in tools_dir.rglob("*.py"):
        # Skip __init__.py and other special files
        if py_file.name.startswith("__"):
            continue
        
        # Skip files that don't contain BaseTool subclasses
        if not file_contains_basetool_subclass(py_file):
            continue
        
        # Build module import path relative to project root
        # e.g., src/large_language_model/tools/datetime_tool.py -> src.large_language_model.tools.datetime_tool
        try:
            rel_path = py_file.relative_to(project_root)
            module_path = ".".join(rel_path.with_suffix("").parts)
            modules.add(module_path)
        except ValueError:
            print(f"Warning: Could not determine relative path for {py_file}")
            continue
    
    return sorted(modules)


def generate_imports_file(modules: List[str], output_path: Path) -> None:
    """
    Generate the Python file containing the import_generated_tools function.
    
    Args:
        modules: List of module paths to import
        output_path: Where to write the generated file
    """
    lines = [
        "# AUTOGENERATED FILE - DO NOT EDIT",
        "# Generated by generators/generate_tool_imports.py",
        "#",
        "# This file contains static imports for all BaseTool subclasses.",
        "# It is generated to replace dynamic imports.",
        "",
        "import importlib",
        "import logging",
        "",
        "logger = logging.getLogger(__name__)",
        "",
        "",
        "def import_generated_tools() -> None:",
        '    """',
        "    Import all modules that contain BaseTool subclasses.",
        "    ",
        "    This function is called by import_tools() to statically import",
        "    all tool modules, providing better performance and determinism",
        "    than dynamic imports at runtime.",
        '    """',
    ]
    
    if not modules:
        lines.append("    # No tool modules found")
        lines.append("    pass")
    else:
        lines.append(f"    # Importing {len(modules)} tool module(s)")
        for module in modules:
            lines.append(f"    try:")
            lines.append(f'        importlib.import_module("{module}")')
            lines.append(f"    except ImportError as e:")
            lines.append(f'        logger.error(f"Failed to import {module}: {{e}}")')
    
    lines.append("")
    
    content = "\n".join(lines)
    output_path.write_text(content, encoding='utf-8')
    print(f"✓ Generated {output_path}")
    print(f"  - Found {len(modules)} module(s) with BaseTool subclasses")
    if modules:
        for module in modules:
            print(f"    • {module}")


def main():
    """Main entry point for the generator script."""
    print("Static Tool Imports Generator")
    print("=" * 50)
    print(f"Project root: {PROJECT_ROOT}")
    print(f"Tools directory: {TOOLS_DIR}")
    print(f"Output file: {OUTPUT_FILE}")
    print()
    
    # Find all modules with BaseTool subclasses
    modules = find_modules_with_tools(TOOLS_DIR)
    
    # Generate the imports file
    generate_imports_file(modules, OUTPUT_FILE)
    
    print()
    print("✓ Generation complete!")


if __name__ == "__main__":
    main()
